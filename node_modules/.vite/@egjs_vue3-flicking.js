import {
  ALIGN,
  AnchorPoint,
  AnimatingState,
  AxesController,
  BoundCameraMode,
  CIRCULAR_FALLBACK,
  CLASS,
  CODE,
  Camera,
  CircularCameraMode,
  Control,
  DIRECTION,
  DisabledState,
  DraggingState,
  EVENTS,
  ExternalRenderer,
  Flicking,
  FlickingError,
  FreeControl,
  HoldingState,
  IdleState,
  LinearCameraMode,
  MOVE_TYPE,
  NormalRenderingStrategy,
  Panel,
  Renderer,
  SnapControl,
  State,
  StateMachine,
  StrictControl,
  VanillaElementProvider,
  VanillaRenderer,
  Viewport,
  VirtualElementProvider,
  VirtualManager,
  VirtualPanel,
  VirtualRenderingStrategy,
  checkExistence,
  circulateIndex,
  circulatePosition,
  clamp,
  component_esm_default,
  find,
  findIndex,
  findRight,
  getDefaultCameraTransform,
  getDirection,
  getElement,
  getElementSize,
  getFlickingAttached,
  getMinusCompensatedIndex,
  getProgress,
  getRenderingPanels,
  getStyle,
  includes,
  isBetween,
  isString,
  merge,
  parseAlign$1,
  parseArithmeticExpression,
  parseArithmeticSize,
  parseBounce,
  parseCSSSizeValue,
  parseElement,
  parsePanelAlign,
  range,
  setPrototypeOf,
  setSize,
  sync,
  toArray,
  withFlickingMethods
} from "./chunk-VYVAKAWC.js";
import "./chunk-CA42FF4U.js";
import {
  Comment,
  Fragment,
  Text,
  defineComponent,
  getCurrentInstance,
  h,
  resolveComponent
} from "./chunk-VP64S72B.js";
import "./chunk-QK4FDCAK.js";
import "./chunk-7FP5O474.js";

// node_modules/@egjs/list-differ/dist/list-differ.esm.js
var PolyMap = function() {
  function PolyMap2() {
    this.keys = [];
    this.values = [];
  }
  var __proto = PolyMap2.prototype;
  __proto.get = function(key) {
    return this.values[this.keys.indexOf(key)];
  };
  __proto.set = function(key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };
  return PolyMap2;
}();
var HashMap = function() {
  function HashMap2() {
    this.object = {};
  }
  var __proto = HashMap2.prototype;
  __proto.get = function(key) {
    return this.object[key];
  };
  __proto.set = function(key, value) {
    this.object[key] = value;
  };
  return HashMap2;
}();
var SUPPORT_MAP = typeof Map === "function";
var Link = function() {
  function Link2() {
  }
  var __proto = Link2.prototype;
  __proto.connect = function(prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };
  __proto.disconnect = function() {
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };
  __proto.getIndex = function() {
    var link = this;
    var index = -1;
    while (link) {
      link = link.prev;
      ++index;
    }
    return index;
  };
  return Link2;
}();
function orderChanged(changed, fixed) {
  var fromLinks = [];
  var toLinks = [];
  changed.forEach(function(_a) {
    var from = _a[0], to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  });
  fromLinks.forEach(function(link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function(_, i) {
    return !fixed[i];
  }).map(function(_a, i) {
    var from = _a[0], to = _a[1];
    if (from === to) {
      return [0, 0];
    }
    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex();
    fromLink.disconnect();
    if (!toLink) {
      fromLink.connect(void 0, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }
    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}
var Result = function() {
  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }
  var __proto = Result2.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function() {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }
      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function() {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }
      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });
  __proto.caculateOrdered = function() {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function(_a, i) {
      var from = _a[0], to = _a[1];
      var _b = changed[i], fromBefore = _b[0], toBefore = _b[1];
      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };
  return Result2;
}();
function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;
  var callback = findKeyCallback || function(e) {
    return e;
  };
  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0;
  prevKeys.forEach(function(key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function(key, listIndex) {
    keyMap.set(key, listIndex);
  });
  prevKeys.forEach(function(key, prevListIndex) {
    var listIndex = keyMap.get(key);
    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  });
  keys.forEach(function(key, listIndex) {
    var prevListIndex = prevKeyMap.get(key);
    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);
      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  });
  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}
var ListDiffer = function() {
  function ListDiffer2(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }
    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  var __proto = ListDiffer2.prototype;
  __proto.update = function(list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };
  return ListDiffer2;
}();
var list_differ_esm_default = ListDiffer;

// node_modules/@egjs/vue3-flicking/dist/flicking.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var FlickingProps = {
  viewportTag: {
    type: String,
    default: "div",
    required: false
  },
  cameraTag: {
    type: String,
    default: "div",
    required: false
  },
  hideBeforeInit: {
    type: Boolean,
    default: false,
    required: false
  },
  firstPanelSize: {
    type: String,
    required: false
  },
  options: {
    type: Object,
    default: function() {
      return {};
    },
    required: false
  },
  plugins: {
    type: Array,
    default: function() {
      return [];
    },
    required: false
  },
  status: {
    type: Object,
    required: false
  }
};
var VueRenderer = function(_super) {
  __extends(VueRenderer2, _super);
  function VueRenderer2(options) {
    var _this = _super.call(this, options) || this;
    _this._vueFlicking = options.vueFlicking;
    return _this;
  }
  var __proto = VueRenderer2.prototype;
  __proto.render = function() {
    return __awaiter(this, void 0, void 0, function() {
      var flicking, vueFlicking, strategy;
      return __generator(this, function(_a) {
        flicking = getFlickingAttached(this._flicking);
        vueFlicking = this._vueFlicking;
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [
          2,
          new Promise(function(resolve) {
            vueFlicking.renderEmitter.once("render", resolve);
            vueFlicking.$forceUpdate();
          })
        ];
      });
    });
  };
  __proto.forceRenderAllPanels = function() {
    return __awaiter(this, void 0, void 0, function() {
      var vueFlicking;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            vueFlicking = this._vueFlicking;
            return [
              4,
              _super.prototype.forceRenderAllPanels.call(this)
            ];
          case 1:
            _a.sent();
            return [
              2,
              new Promise(function(resolve) {
                vueFlicking.renderEmitter.once("render", resolve);
                vueFlicking.$forceUpdate();
              })
            ];
        }
      });
    });
  };
  __proto._collectPanels = function() {
    var flicking = getFlickingAttached(this._flicking);
    var vueFlicking = this._vueFlicking;
    var childRefs = vueFlicking.$refs;
    var vuePanels = Object.keys(childRefs).map(function(refKey) {
      return childRefs[refKey];
    });
    this._panels = this._strategy.collectPanels(flicking, vuePanels);
  };
  __proto._createPanel = function(externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };
  return VueRenderer2;
}(ExternalRenderer);
var VuePanel = defineComponent({
  data: function() {
    return {
      hide: false
    };
  },
  render: function() {
    if (this.hide || !this.$slots.default)
      return;
    return this.$slots.default();
  }
});
var VueElementProvider = function() {
  function VueElementProvider2(el) {
    this._el = el;
  }
  var __proto = VueElementProvider2.prototype;
  Object.defineProperty(__proto, "rendered", {
    get: function() {
      return !this._el.hide;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "element", {
    get: function() {
      var el = this._el.$el.nextSibling;
      if (el && el.nodeType === Node.ELEMENT_NODE) {
        this._cachedElement = el;
      }
      return this._cachedElement;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function() {
    this._el.hide = false;
  };
  __proto.hide = function() {
    this._el.hide = true;
  };
  return VueElementProvider2;
}();
var Flicking2 = defineComponent({
  props: FlickingProps,
  components: {
    Panel: VuePanel
  },
  data: function() {
    return {};
  },
  created: function() {
    var _this = this;
    this.vanillaFlicking = null;
    this.renderEmitter = new component_esm_default();
    this.diffResult = null;
    this.getPanels = function() {
      var componentInstance = getCurrentInstance();
      var vueFlicking = componentInstance === null || componentInstance === void 0 ? void 0 : componentInstance.ctx;
      var flicking = _this.vanillaFlicking;
      var defaultSlots = _this.getSlots();
      var diffResult = vueFlicking === null || vueFlicking === void 0 ? void 0 : vueFlicking.diffResult;
      var slots = diffResult ? getRenderingPanels(flicking, diffResult) : defaultSlots;
      var panelComponent = resolveComponent("Panel");
      var panels = slots.map(function(slot, idx) {
        return h(panelComponent, {
          key: slot.key,
          ref: idx.toString()
        }, function() {
          return slot;
        });
      });
      return panels;
    };
    this.getVirtualPanels = function() {
      var options = _this.options;
      var _a = options.virtual.panelClass, panelClass = _a === void 0 ? "flicking-panel" : _a;
      var panelsPerView = options.panelsPerView;
      var flicking = _this.vanillaFlicking;
      var initialized = flicking && flicking.initialized;
      var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
      var firstPanel = initialized && flicking.panels[0];
      var size = firstPanel ? flicking.horizontal ? {
        width: firstPanel.size
      } : {
        height: firstPanel.size
      } : {};
      return renderingIndexes.map(function(idx) {
        return h("div", {
          key: idx,
          ref: idx.toString(),
          class: panelClass,
          style: size,
          "data-element-index": idx
        });
      });
    };
    withFlickingMethods(this, "vanillaFlicking");
  },
  mounted: function() {
    var _this = this;
    var _a;
    var options = this.options;
    var viewportEl = this.$el;
    var rendererOptions = {
      vueFlicking: this,
      align: options.align,
      strategy: options.virtual && ((_a = options.panelsPerView) !== null && _a !== void 0 ? _a : -1) > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: VueElementProvider
      })
    };
    var flicking = new Flicking(viewportEl, __assign(__assign({}, options), {
      externalRenderer: new VueRenderer(rendererOptions)
    }));
    this.vanillaFlicking = flicking;
    flicking.once(EVENTS.READY, function() {
      _this.$forceUpdate();
    });
    var slots = this.getSlots();
    this.slotDiffer = new list_differ_esm_default(slots, function(vnode) {
      return vnode.key;
    });
    this.pluginsDiffer = new list_differ_esm_default();
    this.bindEvents();
    this.checkPlugins();
    if (this.status) {
      flicking.setStatus(this.status);
    }
  },
  beforeUnmount: function() {
    var _a;
    (_a = this.vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  },
  beforeMount: function() {
    this.fillKeys();
  },
  beforeUpdate: function() {
    this.fillKeys();
    this.diffResult = this.slotDiffer.update(this.getSlots());
  },
  updated: function() {
    var flicking = this.vanillaFlicking;
    var diffResult = this.diffResult;
    this.checkPlugins();
    this.renderEmitter.trigger("render");
    if (!diffResult || !(flicking === null || flicking === void 0 ? void 0 : flicking.initialized))
      return;
    var children = this.getChildren();
    sync(flicking, diffResult, children);
    if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
      this.$forceUpdate();
    }
    this.diffResult = void 0;
  },
  render: function() {
    var _a;
    var flicking = this.vanillaFlicking;
    var options = this.options;
    var initialized = flicking && flicking.initialized;
    var isHorizontal = flicking ? flicking.horizontal : (_a = this.options.horizontal) !== null && _a !== void 0 ? _a : true;
    var viewportData = {
      class: {
        "flicking-viewport": true,
        "vertical": !isHorizontal,
        "flicking-hidden": this.hideBeforeInit && !initialized
      }
    };
    var cameraData = {
      class: {
        "flicking-camera": true
      },
      style: !initialized && this.firstPanelSize ? {
        transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize)
      } : {}
    };
    var panels = options.virtual && options.panelsPerView && options.panelsPerView > 0 ? this.getVirtualPanels : this.getPanels;
    var viewportSlots = this.$slots.viewport ? this.$slots.viewport() : [];
    return h(this.viewportTag, viewportData, __spreadArray([h(this.cameraTag, cameraData, {
      default: panels
    })], viewportSlots, true));
  },
  methods: {
    getSlots: function() {
      var _this = this;
      var slots = this.$slots.default ? this.$slots.default() : [];
      return slots.reduce(function(elementSlots, slot) {
        return __spreadArray(__spreadArray([], elementSlots, true), _this.getElementVNodes(slot), true);
      }, []).filter(function(slot) {
        return slot.type !== Comment && slot.type !== Text;
      });
    },
    getElementVNodes: function(slot, childSlots) {
      var _this = this;
      if (childSlots === void 0) {
        childSlots = [];
      }
      if (slot.type === Fragment && Array.isArray(slot.children)) {
        slot.children.filter(function(child) {
          return child && typeof child === "object";
        }).forEach(function(child) {
          return _this.getElementVNodes(child, childSlots);
        });
      } else {
        childSlots.push(slot);
      }
      return childSlots;
    },
    bindEvents: function() {
      var _this = this;
      var flicking = this.vanillaFlicking;
      var events = Object.keys(EVENTS).map(function(key) {
        return EVENTS[key];
      });
      events.forEach(function(eventName) {
        flicking.on(eventName, function(e) {
          e.currentTarget = _this;
          _this.$emit(eventName.replace(/([A-Z])/g, "-$1").toLowerCase(), e);
        });
      });
    },
    checkPlugins: function() {
      var _a, _b;
      var _c = this.pluginsDiffer.update(this.plugins), list = _c.list, added = _c.added, removed = _c.removed, prevList = _c.prevList;
      (_a = this.vanillaFlicking).addPlugins.apply(_a, added.map(function(index) {
        return list[index];
      }));
      (_b = this.vanillaFlicking).removePlugins.apply(_b, removed.map(function(index) {
        return prevList[index];
      }));
    },
    fillKeys: function() {
      var vnodes = this.getSlots();
      vnodes.forEach(function(node, idx) {
        if (node.key == null) {
          node.key = "$_".concat(idx);
        }
      });
    },
    getChildren: function() {
      var childRefs = this.$refs;
      return Object.keys(childRefs).map(function(refKey) {
        return childRefs[refKey];
      });
    }
  }
});

// dep:@egjs_vue3-flicking
var egjs_vue3_flicking_default = Flicking2;
export {
  ALIGN,
  AnchorPoint,
  AnimatingState,
  AxesController,
  BoundCameraMode,
  CIRCULAR_FALLBACK,
  CLASS,
  Camera,
  CircularCameraMode,
  Control,
  DIRECTION,
  DisabledState,
  DraggingState,
  CODE as ERROR_CODE,
  EVENTS,
  ExternalRenderer,
  FlickingError,
  FreeControl,
  HoldingState,
  IdleState,
  LinearCameraMode,
  MOVE_TYPE,
  NormalRenderingStrategy,
  Panel,
  Renderer,
  SnapControl,
  State,
  StateMachine,
  StrictControl,
  VanillaElementProvider,
  VanillaRenderer,
  Viewport,
  VirtualElementProvider,
  VirtualManager,
  VirtualPanel,
  VirtualRenderingStrategy,
  checkExistence,
  circulateIndex,
  circulatePosition,
  clamp,
  egjs_vue3_flicking_default as default,
  find,
  findIndex,
  findRight,
  getDefaultCameraTransform,
  getDirection,
  getElement,
  getElementSize,
  getFlickingAttached,
  getMinusCompensatedIndex,
  getProgress,
  getRenderingPanels,
  getStyle,
  includes,
  isBetween,
  isString,
  merge,
  parseAlign$1 as parseAlign,
  parseArithmeticExpression,
  parseArithmeticSize,
  parseBounce,
  parseCSSSizeValue,
  parseElement,
  parsePanelAlign,
  range,
  setPrototypeOf,
  setSize,
  sync,
  toArray,
  withFlickingMethods
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@egjs_vue3-flicking.js.map
