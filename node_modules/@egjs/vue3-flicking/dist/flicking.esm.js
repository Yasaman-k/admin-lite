/*
Copyright (c) NAVER Corp.
name: @egjs/vue3-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/tree/master/packages/vue3-flicking
version: 4.9.1
*/
import { defineComponent, getCurrentInstance, resolveComponent, h, Comment, Text, Fragment } from 'vue';
import ListDiffer from '@egjs/list-differ';
import Component from '@egjs/component';
import VanillaFlicking__default, { getFlickingAttached, ExternalRenderer, getRenderingPanels, range, withFlickingMethods, VirtualRenderingStrategy, NormalRenderingStrategy, EVENTS, sync, getDefaultCameraTransform } from '@egjs/flicking';
export * from '@egjs/flicking';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var FlickingProps = {
  viewportTag: {
    type: String,
    default: "div",
    required: false
  },
  cameraTag: {
    type: String,
    default: "div",
    required: false
  },
  hideBeforeInit: {
    type: Boolean,
    default: false,
    required: false
  },
  firstPanelSize: {
    type: String,
    required: false
  },
  options: {
    type: Object,
    default: function () {
      return {};
    },
    required: false
  },
  plugins: {
    type: Array,
    default: function () {
      return [];
    },
    required: false
  },
  status: {
    type: Object,
    required: false
  }
};

var VueRenderer =
/*#__PURE__*/
function (_super) {
  __extends(VueRenderer, _super);

  function VueRenderer(options) {
    var _this = _super.call(this, options) || this;

    _this._vueFlicking = options.vueFlicking;
    return _this;
  }

  var __proto = VueRenderer.prototype;

  __proto.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, vueFlicking, strategy;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        vueFlicking = this._vueFlicking;
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [2
        /*return*/
        , new Promise(function (resolve) {
          vueFlicking.renderEmitter.once("render", resolve);
          vueFlicking.$forceUpdate();
        })];
      });
    });
  };

  __proto.forceRenderAllPanels = function () {
    return __awaiter(this, void 0, void 0, function () {
      var vueFlicking;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            vueFlicking = this._vueFlicking;
            return [4
            /*yield*/
            , _super.prototype.forceRenderAllPanels.call(this)];

          case 1:
            _a.sent();

            return [2
            /*return*/
            , new Promise(function (resolve) {
              vueFlicking.renderEmitter.once("render", resolve);
              vueFlicking.$forceUpdate();
            })];
        }
      });
    });
  };

  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var vueFlicking = this._vueFlicking;
    var childRefs = vueFlicking.$refs;
    var vuePanels = Object.keys(childRefs).map(function (refKey) {
      return childRefs[refKey];
    });
    this._panels = this._strategy.collectPanels(flicking, vuePanels);
  };

  __proto._createPanel = function (externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };

  return VueRenderer;
}(ExternalRenderer);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var VuePanel = defineComponent({
  data: function () {
    return {
      hide: false
    };
  },
  render: function () {
    if (this.hide || !this.$slots.default) return;
    return this.$slots.default();
  }
});

var VueElementProvider =
/*#__PURE__*/
function () {
  function VueElementProvider(el) {
    this._el = el;
  }

  var __proto = VueElementProvider.prototype;
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._el.hide;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "element", {
    get: function () {
      var el = this._el.$el.nextSibling;

      if (el && el.nodeType === Node.ELEMENT_NODE) {
        this._cachedElement = el;
      }

      return this._cachedElement;
    },
    enumerable: false,
    configurable: true
  });

  __proto.show = function () {
    this._el.hide = false;
  };

  __proto.hide = function () {
    this._el.hide = true;
  };

  return VueElementProvider;
}();

var Flicking = defineComponent({
  props: FlickingProps,
  components: {
    Panel: VuePanel
  },
  data: function () {
    return {};
  },
  created: function () {
    var _this = this;

    this.vanillaFlicking = null;
    this.renderEmitter = new Component();
    this.diffResult = null;

    this.getPanels = function () {
      var componentInstance = getCurrentInstance();
      var vueFlicking = componentInstance === null || componentInstance === void 0 ? void 0 : componentInstance.ctx;
      var flicking = _this.vanillaFlicking;

      var defaultSlots = _this.getSlots();

      var diffResult = vueFlicking === null || vueFlicking === void 0 ? void 0 : vueFlicking.diffResult;
      var slots = diffResult ? getRenderingPanels(flicking, diffResult) : defaultSlots;
      var panelComponent = resolveComponent("Panel");
      var panels = slots.map(function (slot, idx) {
        return h(panelComponent, {
          key: slot.key,
          ref: idx.toString()
        }, function () {
          return slot;
        });
      });
      return panels;
    };

    this.getVirtualPanels = function () {
      var options = _this.options;
      var _a = options.virtual.panelClass,
          panelClass = _a === void 0 ? "flicking-panel" : _a;
      var panelsPerView = options.panelsPerView;
      var flicking = _this.vanillaFlicking;
      var initialized = flicking && flicking.initialized;
      var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
      var firstPanel = initialized && flicking.panels[0];
      var size = firstPanel ? flicking.horizontal ? {
        width: firstPanel.size
      } : {
        height: firstPanel.size
      } : {};
      return renderingIndexes.map(function (idx) {
        return h("div", {
          key: idx,
          ref: idx.toString(),
          class: panelClass,
          style: size,
          "data-element-index": idx
        });
      });
    };

    withFlickingMethods(this, "vanillaFlicking");
  },
  mounted: function () {
    var _this = this;

    var _a;

    var options = this.options;
    var viewportEl = this.$el;
    var rendererOptions = {
      vueFlicking: this,
      align: options.align,
      strategy: options.virtual && ((_a = options.panelsPerView) !== null && _a !== void 0 ? _a : -1) > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: VueElementProvider
      })
    };
    var flicking = new VanillaFlicking__default(viewportEl, __assign(__assign({}, options), {
      externalRenderer: new VueRenderer(rendererOptions)
    }));
    this.vanillaFlicking = flicking;
    flicking.once(EVENTS.READY, function () {
      _this.$forceUpdate();
    });
    var slots = this.getSlots();
    this.slotDiffer = new ListDiffer(slots, function (vnode) {
      return vnode.key;
    });
    this.pluginsDiffer = new ListDiffer();
    this.bindEvents();
    this.checkPlugins();

    if (this.status) {
      flicking.setStatus(this.status);
    }
  },
  beforeUnmount: function () {
    var _a;

    (_a = this.vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  },
  beforeMount: function () {
    this.fillKeys();
  },
  beforeUpdate: function () {
    this.fillKeys();
    this.diffResult = this.slotDiffer.update(this.getSlots());
  },
  updated: function () {
    var flicking = this.vanillaFlicking;
    var diffResult = this.diffResult;
    this.checkPlugins();
    this.renderEmitter.trigger("render");
    if (!diffResult || !(flicking === null || flicking === void 0 ? void 0 : flicking.initialized)) return;
    var children = this.getChildren();
    sync(flicking, diffResult, children);

    if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
      this.$forceUpdate();
    }

    this.diffResult = undefined;
  },
  render: function () {
    var _a;

    var flicking = this.vanillaFlicking;
    var options = this.options;
    var initialized = flicking && flicking.initialized;
    var isHorizontal = flicking ? flicking.horizontal : (_a = this.options.horizontal) !== null && _a !== void 0 ? _a : true;
    var viewportData = {
      class: {
        "flicking-viewport": true,
        "vertical": !isHorizontal,
        "flicking-hidden": this.hideBeforeInit && !initialized
      }
    };
    var cameraData = {
      class: {
        "flicking-camera": true
      },
      style: !initialized && this.firstPanelSize ? {
        transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize)
      } : {}
    };
    var panels = options.virtual && options.panelsPerView && options.panelsPerView > 0 ? this.getVirtualPanels : this.getPanels;
    var viewportSlots = this.$slots.viewport ? this.$slots.viewport() : [];
    return h(this.viewportTag, viewportData, __spreadArray([h(this.cameraTag, cameraData, {
      default: panels
    })], viewportSlots, true));
  },
  methods: {
    getSlots: function () {
      var _this = this;

      var slots = this.$slots.default ? this.$slots.default() : [];
      return slots.reduce(function (elementSlots, slot) {
        return __spreadArray(__spreadArray([], elementSlots, true), _this.getElementVNodes(slot), true);
      }, []).filter(function (slot) {
        return slot.type !== Comment && slot.type !== Text;
      });
    },
    getElementVNodes: function (slot, childSlots) {
      var _this = this;

      if (childSlots === void 0) {
        childSlots = [];
      }

      if (slot.type === Fragment && Array.isArray(slot.children)) {
        slot.children.filter(function (child) {
          return child && typeof child === "object";
        }).forEach(function (child) {
          return _this.getElementVNodes(child, childSlots);
        });
      } else {
        childSlots.push(slot);
      }

      return childSlots;
    },
    bindEvents: function () {
      var _this = this;

      var flicking = this.vanillaFlicking;
      var events = Object.keys(EVENTS).map(function (key) {
        return EVENTS[key];
      });
      events.forEach(function (eventName) {
        flicking.on(eventName, function (e) {
          e.currentTarget = _this; // Make events from camelCase to kebab-case

          _this.$emit(eventName.replace(/([A-Z])/g, "-$1").toLowerCase(), e);
        });
      });
    },
    checkPlugins: function () {
      var _a, _b;

      var _c = this.pluginsDiffer.update(this.plugins),
          list = _c.list,
          added = _c.added,
          removed = _c.removed,
          prevList = _c.prevList;

      (_a = this.vanillaFlicking).addPlugins.apply(_a, added.map(function (index) {
        return list[index];
      }));

      (_b = this.vanillaFlicking).removePlugins.apply(_b, removed.map(function (index) {
        return prevList[index];
      }));
    },
    fillKeys: function () {
      var vnodes = this.getSlots();
      vnodes.forEach(function (node, idx) {
        if (node.key == null) {
          node.key = "$_".concat(idx);
        }
      });
    },
    getChildren: function () {
      var childRefs = this.$refs;
      return Object.keys(childRefs).map(function (refKey) {
        return childRefs[refKey];
      });
    }
  }
});

export { Flicking as default };
//# sourceMappingURL=flicking.esm.js.map
